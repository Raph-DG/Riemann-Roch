import Mathlib
import RiemannRoch.AlgebraicCycle.Basic
import RiemannRoch.AlgebraicCycle.Principal

/-!
# Algebraic Cycles

In this file we wish to show that for any point `x` on a (locally??) Noetherian, integral scheme,
whose local rings are all unique factorization domains that for any Weil divisor `D` there is a
neighbourhood `U` of `x` and a rational function `f` such that `D` restricted to `U` is equal to
`div f` restricted to `U`.

The proof of this fact goes as follows. We first show this is the case for a prime divisor. The
general case then follows since `∑ₙ aₙ Pₙ` should be generated by `∏ₙ fₙ ^ aₙ` by our div
homomorphism fact.

The argument for prime divisors goes as follows. Say we have some irreducible closed subset `D` of
`X`. Then, around our point `x`, take some affine open `U = Spec R` such that inside `U`,
`D` is given by some prime ideal `I` of `R`. The stalk of `x` is given by the localization of `R` at
the ideal of `x`. Hence, the image of `D` at the stalk of `x` is given by the image of `I` under
the localization map. We can show that this must be a principal ideal by some comm alg nonsense,
call this generator `fₓ`. But there are only finitely many points of `D` and they all have
-/

open AlgebraicGeometry

universe u
variable (X : Scheme.{u}) [IsIntegral X] [IsLocallyNoetherian X]
    [h : ∀ x : X, UniqueFactorizationMonoid (X.presheaf.stalk x)]


open AlgebraicCycle Order

variable (p : X)

#check single p 1
/-
This is how we represent a prime divisor (is this reasonable?)
-/

open UniqueFactorizationMonoid in
lemma algebraLemma (R : Type*) [CommRing R] [IsDedekindDomain R]
        [UniqueFactorizationMonoid R] : IsPrincipalIdealRing R := by
    constructor
    intro I

    /-
    Use that I is a product of prime ideals
    -/

    /-
    Note that the product of principal ideals is principal, so it suffices to just
    show this result holds for prime ideals.
    -/
    wlog h : I.IsPrime
    · sorry

    by_cases k : ∃ x ∈ I, x ≠ 0
    · obtain ⟨x, hx1, hx2⟩ := k

      /-
      x cannot be a unit since h is a prime (and hence proper) ideal.
      -/
      have : ¬ IsUnit x := by
        have := h.ne_top
        have cont : I < ⊤ := by exact Ne.lt_top' (id (Ne.symm this))
        intro k
        have : Submodule.span  R {x} = ⊤ := by aesop
        rw [← this] at cont
        have : Submodule.span R {x} ≤ I := by exact
          (Submodule.span_singleton_le_iff_mem x I).mpr hx1
        rw [lt_iff_le_not_ge] at cont
        exact cont.2 this

      /-
      Since R is a UFD, x must have a unique factorization `x = p₁ᵃ¹p₂ᵃ²...pₙᵃⁿ`,
      where n is strictly positive since x is not a unit.
      -/

      let fact := UniqueFactorizationMonoid.factors x

      /-
      Since `I` is prime, it follows that some `pᵢ` (say `p₁`) is in `I`,
      hence `(p₁) ⊆ I`.

      More specifically, if `x = p`, then `p` is in `I` by assumption.
      Otherwise, there must be at least two elements of the decomposition, and
      since I is prime this means one of the factors must be in the decomposition
      -/
      have : ∃ p ∈ fact, p ∈ I := by
        induction x using induction_on_prime
        · simp_all
        · contradiction
        · rename_i a b ha hb e
          obtain o | o := h.mem_or_mem hx1
          · use b
            simp [o]
            /-
            This should be trivial, which tells me I may be proving the wrong
            statement
            -/
            sorry
          · have := e o ha
            /-
            Here we need to abstract the above lemma about elements of prime ideals
            not being units into its own lemma.
            -/
            sorry

      obtain ⟨p, hp⟩ := this
      /-
      We split into cases, either `(p₁) = I` or `(p₁) ⊂ I`.
      -/
      by_cases o : Submodule.span R {p} = I


      · /-
        In the first case we are done since `I` is principal (as witnessed by generator `p₁`).
        -/
        constructor
        grind
      · /-
        For the second case, note `(p₁)` must be prime since any ideal generated by an irreducible in
        a UFD must be prime
        -/
        have : Ideal.IsPrime <| Submodule.span R {p} := sorry

        /-
        Hence, we have the following chain of prime ideals:

        `0 ⊂ (p₁) ⊂ I`
        -/

        --have : ringKrullDim R ≤ 1 := sorry

        let p : LTSeries (PrimeSpectrum R) := {
          length := 2
          toFun i := if i = 0 then ⊥ else (if i = 1 then ⟨Submodule.span R {p}, this⟩ else ⟨I, h⟩)
          step i := if k : i = 0
                    then by
                      simp[k]
                      --have : OrderBot <| PrimeSpectrum R := sorry

                      --suffices ⟨Submodule.span R {p}, this⟩ ≠ (⊥ : PrimeSpectrum R) by sorry
                      rw [← @PrimeSpectrum.asIdeal_lt_asIdeal]
                      simp
                      apply lt_of_le_of_ne
                      · exact bot_le
                      · suffices Ideal.span {p} ≠ ⊥ by exact id (Ne.symm this)
                        suffices p ≠ 0 by sorry
                        /-
                        Should follow from some API about factors
                        -/
                        sorry
                    else by
                      simp [k]
                      have k' : i = 1 := sorry
                      simp [k']
                      rw [← @PrimeSpectrum.asIdeal_lt_asIdeal]
                      simp
                      apply lt_of_le_of_ne
                      · have := hp.2
                        exact (Ideal.span_singleton_le_iff_mem I).mpr this
                      · assumption
        }
        have cont : ringKrullDim R = 1 := by sorry -- True by assumption, we may be able to weaken our assumptions to just use this

        simp [ringKrullDim, krullDim] at cont
        have : (p.length : ℕ∞) ≤ ⨆ q : LTSeries (PrimeSpectrum R), (q.length : ℕ∞) := by sorry


        --have : I.height ≥ 2 := by

        --    sorry
        --#check KrullDimLE

        /-
        Since this is of length `2`, but our ring was assumed to have krull dimension `1`,
        this gives a contradiction.
        -/



        sorry
    · /-
      In this case `I` has no nonzero elements, and so must be principal
      -/
      constructor
      aesop



lemma AlgebraicCycle.exists_local_factorization (x p : X) (hp : coheight p = 1) :
        ∃ (U : X.Opens) (_ : x ∈ U) (f : X.functionField) (hf : f ≠ 0),
        (single p 1).restrict (by simp : U ≤ ⊤) = (div f hf).restrict (by simp) := by
    obtain ⟨U, affU, xinU, triv⟩ := exists_isAffineOpen_mem_and_subset (by simp : x ∈ ⊤)

    wlog h : ∃ R, X = Spec R
    · /-
      If X is not affine, we can take some affine neighbourhood of x to be U.
      In this neighbourhood we can find a neighbourhood of x in which the desired
      property holds
      -/
      sorry
    obtain ⟨R, rfl⟩ := h

    /-
    This follows from the fact that the stalks in our setup are DVRs.
    -/
    have m : IsPrincipalIdealRing ((Spec R).presheaf.stalk x) := sorry

    #check (Spec R).presheaf.germ ⊤ x (by simp)
    --#check (algebraMap (Γ(Spec R, ⊤)) ((Spec R).presheaf.stalk x))
    #check Spec.structureSheaf R
    --let a : Algebra R ((Spec R).sheaf.presheaf.stalk x) := sorry
    let k : Algebra ↑R ↑((Spec R).presheaf.stalk x) := StructureSheaf.stalkAlgebra (↑R) x
    have : IsLocalization.AtPrime (↑((Spec R).presheaf.stalk x)) x.asIdeal :=
      StructureSheaf.IsLocalization.to_stalk R x

    /-
    This is the reason why we're proving this for prime divisors. That said, it could be better to
    decouple these behaviours. Note that we want to be able to map a divisor D to a divisor Dₓ on
    the local scheme at x. For a prime divisor, this is very easy because it's literally just a
    prime ideal. In the other case, we need to build a more general equivalence between divisors
    and ideals.
    -/
    let pₓ := p.asIdeal.map (algebraMap R ((Spec R).presheaf.stalk x)) --(algebraMap R (Localization.AtPrime x.asIdeal))

    obtain ⟨fₓ, hfₓ⟩ := m.principal pₓ

    obtain ⟨Uₓ, xinUₓ, g, hg⟩ := (Spec R).presheaf.germ_exist x fₓ

    have : Nonempty Uₓ := sorry
    have gnez : (Spec R).germToFunctionField Uₓ g ≠ 0 := sorry
    have problemPoints := {z | ¬ (x ≤ z) ∧ ((single p 1 z) ≠ 0 ∨ div ((Spec R).germToFunctionField Uₓ g) gnez z ≠ 0)}
    have ppfinite : problemPoints.Finite := sorry
    have : ∃ (Vₓ : (Spec R).Opens) (_ : x ∈ Vₓ) (_ : Vₓ ≤ Uₓ), Vₓ.1 ∩ problemPoints = ∅ := sorry
    obtain ⟨Vₓ, xinVₓ, blah, hV⟩ := this
    use Vₓ, xinVₓ, (Spec R).germToFunctionField Uₓ g, gnez
    ext z


    by_cases h : z ∈ Vₓ
    · simp [Function.locallyFinsuppWithin.restrict_apply, h]

      by_cases hz : x ≤ z
      ·
        #check IsLocalization.AtPrime.orderIsoOfPrime
        /-
        The idea is that the vanishing of g at z
        -/



        simp [single, div]
        change Set.indicator {p} 1 z =
            if h : coheight z = 1
            then  Multiplicative.toAdd (WithZero.unzero (Scheme.ord_ne_zero h gnez))
            else 0
          --simp [test]
        by_cases test : coheight z = 1

        · simp [test]
          /-
          The height of (fₓ)
          -/


          /-
          This now says that the order of vanishing of g at z is 1 iff p is z.


          -/


          sorry
        · simp [test]
          intro l
          rw [l] at test
          exact (test hp)

        --sorry

      /-
      We know that (fₓ) z = single p 1 z for any z passing through x (i.e. x ≤ z) by some
      theorem about localizations.

      For any other z, we have set things up so that the coefficient must be 0.


      -/
      · have : (single p 1 z) = 0 ∧ div ((Spec R).germToFunctionField Uₓ g) gnez z = 0 := sorry
        simp [this]
    · simp [h]

    /-
    `g` can differ to `f` only at primes not passing through `x`.
    So we want to take `Uₓ` and remove all the points not passing through `x` with
    nonzero vanishing in either `D` or `(fₓ)`. That will give us what we want.
    -/










open Ring in
lemma IsDiscreteValutationRing.not_krullDimLE_zero (R : Type*) [CommRing R] [IsDomain R]
    [IsDiscreteValuationRing R] : ringKrullDim R = 1 := by
  have := DimensionLEOne.principal_ideal_ring R
  suffices KrullDimLE 1 R ∧ ¬ KrullDimLE 0 R by
    simp [Ring.krullDimLE_iff] at this



    sorry
  suffices ¬ KrullDimLE 0 R by

    sorry
  intro a
  have : IsLocalRing R := by exact IsLocalRing.of_singleton_maximalSpectrum
  obtain ⟨ϖ, hϖ⟩ := IsDiscreteValuationRing.exists_irreducible R
  have c := Ring.KrullDimLE.isNilpotent_iff_mem_maximalIdeal (x := ϖ)
  have : ϖ ∈ IsLocalRing.maximalIdeal R := by
    rw [Irreducible.maximalIdeal_eq hϖ]
    exact Ideal.mem_span_singleton_self ϖ
  have := c.mpr this
  aesop
